package LeetCode.JianZhiOffer.BitOperation;

/**
 * @Author: FBY
 * @Date: 2021/4/27 18:02
 * @Version 1.0
 */

/**
 * 实现pow(x,n)，即计算 x 的 n 次幂函数（即，x^n）。不得使用库函数，同时不需要考虑大数问题。
 *
 *
 * 示例 1：
 * 输入：x = 2.00000, n = 10
 * 输出：1024.00000
 *
 * 示例 2：
 * 输入：x = 2.10000, n = 3
 * 输出：9.26100
 *
 * 示例 3：
 * 输入：x = 2.00000, n = -2
 * 输出：0.25000
 * 解释：2^-2 = 1/2^2 = 1/4 = 0.25
 *
 *
 * 提示：
 *
 * -100.0 <x< 100.0
 * -2^31<= n <=2^31-1
 * -10^4<= x^n<= 10^4
 *
 */
public class MyPow {
    /**
     * 思路
     * ·标签：快速幂
     * ·整体思路：
     *      ·直接求 x 的 n 次方是通过循环将 n 个 x 做乘积，时间复杂度为 O(n)O(n)，快速幂法 可将时间复杂度降低至 O(log_n)
     *      ·利用十进制数字 n 的二进制表示，可对快速幂进行数学化解释。
     * 复杂度：
     *      ·时间复杂度：O(log_n)
     *      ·空间复杂度：
     * 算法流程
     * 1.对于任何十进制正整数 n ，设其二进制为 bk...b3b2b1(bi为二进制某位值，i/ni∈[1,k])，则有：
     *  ·二进制转十进制：n = b1+2b2+4b3+...+2^{k-1}bk
     *  ·幂的二进制展开：x^n = x^{b1+2b2+4b3+...+2^{k-1}bk} = x^{b1}x^{2b2}x^{4b3}x^{2^{k-1}bk}
     * 2.根据以上推导，可把计算 x^n转化为解决以下两个问题：
     *  ·计算 x^1,x^2,...,x^{2k-1}的值：循环赋值操作 x = x^2
     *  ·获取二进制各位的值：循环
     *      ·1.判断二进制最右一位是否为 1；
     *      ·2.n 右移一位；
     */
    public double myPow(double x,int n){
        if (x == 0.0f)
            return 0.0d;
        long b = n;
        double result = 1.0;
        if (b<0){
            x = 1/x;
            b = -b;
        }
        while (b>0){
            if ((b & 1) == 1){
                result *= x;
            }
            x *= x;
            b >>= 1;
        }
        return result;
    }
}
