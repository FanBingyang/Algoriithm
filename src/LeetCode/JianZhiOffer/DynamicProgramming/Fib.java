package LeetCode.JianZhiOffer.DynamicProgramming;

/**
 * @Author: FBY
 * @Date: 2021/4/24 21:57
 * @Version 1.0
 */

/**
 * 题目描述
 * 写一个函数，输入 n，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：
 * F(0) = 0, F(1)= 1
 * F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
 * 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
 *
 * 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
 *
 * 示例 1：
 * 输入：n = 2
 * 输出：1
 *
 * 示例 2：
 * 输入：n = 5
 * 输出：5
 *
 * 提示：
 * 0 <= n <= 100
 */
public class Fib {

    /**
     * 思路 1
     * ·标签：动态规划
     * ·本题是经典的动态规划问题，围绕斐波那契数列方程 F(n+1) = F(n) + F(n−1)F(n+1)=F(n)+F(n−1) 进行解题，所以在求 n+1 元素时，只需要知道第 n 和 n-1 个元素即可
     *      ·状态定义： F[n] 表示的含义为斐波那契数列中第 n 个数字
     *      ·转移方程： F(n+1) = F(n) + F(n−1)F(n+1)=F(n)+F(n−1) ，所以在求 n+1 元素时，只需要知道第 n 和 n-1 个元素即可，故而运算过程中不需要保存数组
     *      ·初始状态： F[0] = 0, F[1] = 1 ，因为在计算 n+1 时需要 2 个元素，所以要初始化 2 个值；
     * ·其中取模 1000000007 运算主要是为了避免数字溢出，这步运算在每次计算出新的斐波那契数时进行即可，因为模运算的特性，后续再进行加法运算也不会有任何影响
     *      ·模运算特性：(x + y) % z = ((x % z) + (y % z)) % z
     * ·时间复杂度：O(n)，空间复杂度：O(1)
     */
    public static int fib(int n){
        int n1=0,n2=1,sum;
        for (int i=0;i<n;i++){
            sum = (n1+n2) % 1000000007;
            n1 = n2;
            n2 = sum;
        }
        return n1;
    }

    /**
     * 思路 2
     * ·标签：打表(这个大表就很灵性，人家就是让你计算，这家伙倒好，提前计算好给存上，用哪个就取哪个（项目中有这种需要的话确实可以提前算好，毕竟项目运行的时候就节省时间了，但是该方法不适用于做题，毕竟这101个数字谁记得住啊）)
     * ·首先从题目中可以得出0 <= n <= 100，那么说明结果一共有 101 个数字，如果这 101 个数字可以提前计算好，到时候需要哪个取哪个，就可以最大程度的降低时间复杂度，这个就是打表的思维
     * ·打表虽然看起来就是将所有结果枚举出来，感觉上扩展性也不好，看着也很繁琐，但是在实际做算法题中确实有着很广泛的应用，不失为一种巧妙的解法
     * ·时间复杂度：O(1)，空间复杂度：O(1)
     *
     */
    public static int fib_2(int n){
        int[] f={0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,134903163,836311896,971215059,807526948,778742000,586268941,365010934,951279875,316290802,267570670,583861472,851432142,435293607,286725742,722019349,8745084,730764433,739509517,470273943,209783453,680057396,889840849,569898238,459739080,29637311,489376391,519013702,8390086,527403788,535793874,63197655,598991529,662189184,261180706,923369890,184550589,107920472,292471061,400391533,692862594,93254120,786116714,879370834,665487541,544858368,210345902,755204270,965550172,720754435,686304600,407059028,93363621,500422649,593786270,94208912,687995182};
        return f[n];
    }


    /**
     * 本题可以用动态规划，因为传统的递归会超时
     */
    public static int Myfib(int n){
        if (n==0 || n==1)
            return n;
        else
            return Myfib(n-1)+Myfib(n-2);
    }
}
